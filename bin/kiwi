#!/usr/bin/env bash

#
# Defaults
#

VERSION=0.0.1
ORIGIN=git://github.com/visionmedia/kiwi.git
SERVER_PORT=${SERVER_PORT:-80}
SERVER_ADDR=${SERVER_ADDR:-173.203.199.182}
SERVER=http://$SERVER_ADDR:$SERVER_PORT
KIWI_DEST=~/.kiwi
AUTH_DEST=$KIWI_DEST/.auth
SEED_DEST=$KIWI_DEST/current/seeds

#
# Output usage.
#

usage() {
cat << EOF

  Usage:
    
    ${0##*/} [options] [command] [arguments]
    
  Options:
    
    -v, --verbose     Verbose output
    -V, --version     Current version triplet
    -S, --seeds       Output seed directory
    -h, --help        Help information
    
  Commands:
    
    <void>                       Starts a kiwi interactive console (REPL)
    install <name> [version]     Installs a seed <name> with optional [version]
    uninstall <name> [version]   Uninstalls all versions of seed <name> or the given [version]
    switch <env>                 Switch to kiwi to use the given seed <env>
    search [pattern]             Search remotely available seeds with optional [pattern]
    build <version>              Build <version>.seed with the contents of the current directory
    publish <name> <version>     Push seed <name> and <version> to the kiwi server
    release <name> <version>     Build and publish seed <name> and <version>
    register <name> <password>   Attempt to register the given <user> name and <password>
    update                       Install the latest release of every seed installed
    update self                  Updates kiwi to the latest release
    whoami                       Output currently registered user name
    list                         Lists installed seeds and their associated versions
    envs                         List environments available to kiwi
    
  Install:
  
    Installing the latest version of a seed:
    
      $ kiwi install sass
      
    Installing a specific version:
    
      $ kiwi install sass ">~ major.minor.patch"
  
    The following operators are supported for matching versions:
    
      n/a               Equal to
      =                 Equal to
      >                 Greater than
      >=                Greater than or equal to
      >~                Greater than or equal to with compatibility (major must match)

EOF
}

#
# Abort with the given <msg ...>
# 
# <msg ...>
#

abort() {
  echo Error: $* && exit 1
}

#
# Log the given <msg ...> when $VERBOSE is true.
# 
# <msg ...>
#

log() {
  local key=$1; shift
  [[ $VERBOSE ]] && printf "%10s : %s\n" $key "$*"
}

#
# Switch "current" environment to <env>.
# 
# <env>
#

switch_environment() {
  local dir=$KIWI_DEST/$1
  [[ -d $dir ]] || mkdir -p $dir
  log switch "current -> $1"
  rm -fr $KIWI_DEST/current
  ln -s $dir $KIWI_DEST/current
}

#
# - Create / switch to default environment unless present.
# - Create $SEED_DEST unless present.
# 

setup() {
  [[ -d $KIWI_DEST/default ]] || switch_environment default
  [[ -d $SEED_DEST ]] || mkdir -p $SEED_DEST
}

#
# Create $SEED_DEST/<name>/<version>.
# 
# <name> <version>
#

setup_seed() {
  local dir=$SEED_DEST/$1/$2
  log create $dir
  mkdir -p $dir
}

#
# Pack <version>.seed with the contents of the current directory.
# 
# <version>
#

pack() {
  require_seed_info_file seed.yml
  local tmpfile=$(mktemp -t 'kiwi-ignore')
  if [[ -f .ignore ]]; then
    log ignore globs in .ignore
    ls -AR | egrep --file .ignore > $tmpfile
  fi
  log ignore common scm directories
  echo -e ".git\n.svn\n.cvs" >> $tmpfile
  log pack "* -> $1.seed"
  tar --exclude-from $tmpfile -czf $1.seed .
}

#
# Unpack <seed> using tar.
# 
# <seed>
#

unpack() {
  local seed=$1
  local dir=${seed%/*}
  log unpack $seed
  tar -xzf $seed -C $dir 2> /dev/null
  if [[ $? -ne 0 ]]; then
    log remove $dir
    rm -fr $dir
    abort failed to unpack. Seed is invalid or corrupt.
  fi
  log remove $seed
  rm -f $seed
}

#
# Search remote seeds with the given [pattern].
# 
# [pattern]
#

search() {
  curl -s $SERVER/search?name=$1
}

#
# Download seed <name> with <version> to $SEED_DEST/<name>/<version>/<name>.seed
# 
# Populates global $seed with path to the seed archive.
# 
# <name> <version>
#

download() {
  local name=$1
  local version=$2
  setup_seed $name $version
  log fetch $version.seed
  seed=$SEED_DEST/$name/$version/$name.seed
  curl -s $SERVER/seeds/$name/$version.seed -o $seed
}

#
# Build seed in the given <dir>.
# 
# <dir>
#

build() {
  local dir=$1
  local info=$dir/seed.yml
  require_seed_info_file $info
  local command=$(cat $info | grep build | sed 's/build: *//' )
  if [[ $command ]]; then
    log cd $dir
    cd $dir
    log build $command
    if [[ $VERBOSE ]]; then
      eval $command
    else
      eval "$command > /dev/null"
    fi
  fi
}

#
# Publish the given <version> of the seed <name> in the current directory.
# 
# <name> <version>
#

publish() {
  local name=$1
  local version=$2
  local seed=$version.seed
  [[ ! -f $seed ]] && abort $seed not found.
  require_seed_info_file seed.yml
  require_auth
  log publish "$seed -> $SERVER/$name"
  curl -F seed=@$seed -F info=@seed.yml http://$auth@$SERVER_ADDR:$SERVER_PORT/$name -H 'Accept: text/plain'
}

#
# Install dependencies defined in the given seed info <file>.
# 
# <file>
#

install_dependencies() {
  require_seed_info_file $1
  log check dependencies
  deps=0
  cat $1 | while read line; do
    [[ $line =~ dependencies: ]] && deps=1
    [[ $deps -ne 0 && $line =~ ^\s*- ]] && deps=2
    [[ $deps -eq 2 && $line =~ ^\s*.+: ]] && deps=0
    [[ $deps -eq 2 ]] && kiwi $FLAGS install $(normalize_version $line)
  done
}

#
# Remove empty seed directories.
# 

remove_empty_seed_directories() {
  [[ -z $(ls -A $SEED_DEST/) ]] && exit
  local dirs=$SEED_DEST/*
  for dir in $dirs;
  do
    if [[ -z $(ls -A $dir/) ]]; then
      log remove $dir
      rmdir $dir
    fi
  done
}

#
# Install a seed <name> with [version].
#
# When a <file> is passed, it should be a flat-list
# of seeds to install, formatted as:
#   <name> [op] <version>\n
#   <name> [op] <version>\n
#   ...
#
# Otherwise:
# 
#   - Fetches latest version when [version] absent
#   - Downloads seed tarball
#   - Unpacks the tarball
# 
# <name|file> [version]
#

install() {
  local name=$1; shift
  local version=$*
  log install $name $version
  if [[ -f $name ]]; then
    log install from file
    cat $name | while read line; do
      [[ $line =~ ^\s*- ]] && kiwi $FLAGS install $(normalize_version $line)
    done
  else
    version=$(curl -s $SERVER/$name/resolve?version=$(urlencode $version))
    log resolve version $version
    if [[ -d $SEED_DEST/$name/$version ]]; then
      log install already installed
    else
      download $name $version
      unpack $seed
      build ${seed%/*}
      install_dependencies ${seed%/*}/seed.yml
    fi
  fi
}

#
# Uninstall seed <name> with [version]. When [version] is not
# present all versions of the seed will be removed.
# 
# <name> [version]
#

uninstall() {
  local name=$1
  local version=$2
  if [[ $version ]]; then
    if [[ -d $SEED_DEST/$name/$version ]]; then
      log uninstall $name $version
      rm -fr $SEED_DEST/$name/$version
    else
      abort cannot find version $version of $name
    fi  
  else
    if [[ -d $SEED_DEST/$name ]]; then
      log uninstall all versions of $name
      rm -fr $SEED_DEST/$name
    else
      abort cannot find any versions of $name
    fi
  fi
  remove_empty_seed_directories
}

#
# List install seeds and their associated versions.
# 

list() {
  require_seeds
  local dirs=$SEED_DEST/*
  for dir in $dirs;
  do
    local name=${dir##*/}
    printf "%15s : " $name
    local versions=$SEED_DEST/$name/*
    for version in $versions
    do
      echo -n "${version##*/} "
    done
    echo
  done
}

#
# Open seed directory for the given seed <name>
# 
# <name>
#

open_seed_directory() {
  $EDITOR $SEED_DEST/$1
}

#
# Update kiwi to the latest version.
# 

update_self() {
  cd /tmp && git clone $ORIGIN && 
  cd kiwi && sudo make install &&
  echo -n 'Updated kiwi to ' && kiwi --version
}

#
# Install the latest version of all installed seeds.
# 

update_all() {
  require_seeds
  local dirs=$SEED_DEST/*
  echo
  for dir in $dirs
  do
    install ${dir##*/}
    echo
  done
}

#
# List environments, prefixing '*' to the current env.
# 

list_environments() {
  local link=$(readlink $KIWI_DEST/current)
  local current=${link##*/}
  for dir in $KIWI_DEST/*
  do
    local name=${dir##*/}
    if [[ $name != "current" ]]; then
      if [[ $current = $name ]]; then
        echo "* $name"
      else
        echo "  $name"
      fi
    fi
  done
}

#
# Require authentication.
# 
#  - Populates $auth with the contents of $AUTH_DEST when present
#

require_auth() {
  [[ -f $AUTH_DEST ]] || abort please register before attempting to publish a seed.
  auth=$(cat $AUTH_DEST)
}

#
# Output username.
#

output_username() {
  if [[ -f $AUTH_DEST ]]; then
    local auth=$(cat $AUTH_DEST)
    echo ${auth%%:*}
  else
    echo "Credentials cannot be found, please register first."
    echo "  If you have previously registered simply run:"
    echo "  $ echo user:pass > $AUTH_DEST"
  fi
}

#
# Attempt to register the given <user> with <password>.
# 
#   - Saves credentials to $AUTH_DEST
# 
# <user> <password>
#

register_user() {
  curl -s http://$1:$2@$SERVER_ADDR:$SERVER_PORT/user -d ''
  log create $AUTH_DEST
  echo $1:$2 > $AUTH_DEST
}

#
# Urlencode all args.
# 
# <arg ...>
#

urlencode() {
  echo $(echo $* | sed 's/>/%3e/g;s/=/%3D/g;s/ /%20/g')
}

#
# Normalize version args.
# 
# For example '- sass >= 0.0.1' will become 'sass ">= 0.0.1"',
# making it bash-friendly for installation etc.
# 
# <arg ...>
#

normalize_version() {
  echo $(echo ${*##*-} | awk '{ print $1 " \"" $2 " " $3 "\"" }')
}

#
# Abort unless one or more seeds are installed.
# 

require_seeds() {
  [[ -z $(ls -A $SEED_DEST/) ]] && abort no seeds are installed.
}

#
# Require presence of seed info <file> or abort.
# 
# <file>
#

require_seed_info_file() {
  [[ ! -f $1 ]] && abort seed.yml file required.
}

#
# Require presence of seed <name> or abort.
# 
# <name>
#

require_seed_name() {
  [[ $1 ]] || abort seed name required.
}

#
# Require presence of seed <version> or abort.
# 
# <version>
#

require_seed_version() {
  [[ $1 ]] || abort seed version required.
}

#
# Start kiwi REPL.
# 

repl() {
  echo -n 'kiwi> '
  read line
  [[ $line ]] && eval "kiwi $line"
  repl
}

#
# Parse the given args.
# 
# <arg ...>
#

parse() {
  while [[ $# -gt 0 ]]; do
    arg=$1; shift
    case $arg in
      -V|--version) echo $VERSION ;;
      -S|--seeds) echo $SEED_DEST ;;
      -h|--help|help) usage | less ;;
      -v|--verbose) 
        VERBOSE=1
        FLAGS="$FLAGS --verbose"
        ;;
      --*) 
        abort "invalid option \`$arg'. Use --help for more information"
        ;;
      update)
        if [[ $1 = "self" ]]; then
          update_self 
        else
          update_all
        fi
        ;;
      open)
        require_seed_name $1
        open_seed_directory $*
        ;;
      uninstall|remove|delete|rm)
        require_seed_name $1
        uninstall $* 
        ;;
      install|add|get)
        require_seed_name $1
        install $*
        ;;
      publish)
        require_seed_name $1
        require_seed_version $2
        publish $* 
        ;;
      build)
        require_seed_version $1
        pack $*
        ;;
      release)
        require_seed_name $1
        require_seed_version $2
        pack $2 && publish $*
        ;;
      switch)
        [[ $1 ]] || abort environment name required.
        switch_environment $1
        ;;
      register)
        [[ $1 ]] || abort user name required.
        [[ $2 ]] || abort password required.
        register_user $1 $2
        ;;
      search) 
        search $*
        ;;
      env|envs)
        list_environments
        ;;
      whoami)
        output_username
        ;;
      repl)
        repl
        ;;
      list|ls)
        list $*
        ;;
    esac
  done
}

#
# Setup kiwi requirements.
#

setup

#
# Parse arguments.
#

if [[ $# -eq 0 ]]; then
  if [[ $(which rlwrap) ]]; then
    rlwrap kiwi repl
  else
    kiwi repl
  fi
else
  parse $*  
fi
